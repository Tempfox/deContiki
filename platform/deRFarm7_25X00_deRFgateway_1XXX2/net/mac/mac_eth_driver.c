/*
 * Copyright (c) 2012, Swedish Institute of Computer Science and other contributors.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 *
 */
/**
 * \file
 *         Ethernet MAC file. Moves up IPv6 packets into the stack and
 * 				 handles IPv4 - ARP interactions.
 *
 * \author
 *         Luis Maqueda Ara <luis@sen.se>
 */

#include "net/pgw_netstack.h"	// TODO @@@jwg
#include "net/mac/mac_eth_driver.h"
#include "net/p-gw/pgw_fwd.h"
#include "net/uipv4/uipv4_arp.h"
#include "contiki-net.h"
#include "net/uipv4/uipv4.h"

#define ETH_BUF ((struct uip_eth_hdr *)&uip_buf[0])
#define IPV4_BUF ((struct uipv4_ip_hdr *)&uip_buf[UIP_LLH_LEN])
#define IPV6_BUF ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])

/* event timer to handle arp periodic invocations */
struct etimer mac_eth_periodic;

PROCESS(mac_eth_process, "mac_eth_process");

PROCESS_THREAD(mac_eth_process, ev, data)
{
	PROCESS_BEGIN();

	printf("mac_eth_process started");
	printf("\n");

	etimer_set(&mac_eth_periodic, CLOCK_SECOND * 10);
	while(1) {
    PROCESS_WAIT_EVENT();
    if(ev == PROCESS_EVENT_TIMER) {
      uipv4_arp_timer();
      etimer_restart(&mac_eth_periodic);
    }
  }
  
  PROCESS_END();
}

/*---------------------------------------------------------------------------*/
static void
send_packet()
{	
//	printf("mac_eth_driver.send()\n");
//	printf("\n");

	if ((IPV4_BUF->vhl & 0xf0) == 0x40) {
		/* If the packet is an IPv4 packet generated by the local node,
		 * we ignore the values on src and dest, and let arp set the whole
		 * Ethernet header.
		 * Note that uipv4_arp_out() increases the value of uip_len with the
		 * length of the Ethernet header */
		uipv4_arp_out();
		/* And send the packet. Note that uipv4_arp_out() increases the value of
		 * uip_len with the length of the Ethernet header! */
		NETSTACK_ETHERNET.send(uip_buf, uip_len);
	} else if ((IPV6_BUF->vtc & 0xf0) == 0x60) {
		/* The Ethernet header was already built by pgw; increase the value of 
		 * uip_len and pass the packet to the lower layer */
		uip_len += sizeof(struct uip_eth_hdr);

		{	// TODO @@@jwg
			printf("<<< eth(%u): ", uip_len);
			/* Note the dumped packet will have a zero checksum unless compiled with RF231_CONF_CHECKSUM
			* since we don't know what it will be if calculated by the hardware.
			*/
#if 0
			uint8_t i;
			printf("0000");       //Start a new wireshark packet
			for (i=0;i<uip_len;i++) printf(" %02x",uip_buf[i]);
#endif
			printf("\n");
		}

		NETSTACK_ETHERNET.send(uip_buf, uip_len);
	} else {
		/* Error? */
		uip_len = 0;
		uip_ext_len = 0;
		return;
	}
}

/*---------------------------------------------------------------------------*/
static void input_packet(void) {
//	printf("eth: (%02x) 0000 ", UIP_HTONS(ETH_BUF->type)); // TODO @@@jwg
//	for ( int i = 0; i < uip_len; ++i) {
//		printf("%02x ", uip_aligned_buf.u8[i]);
//	}
//	printf("\n");

/* Multiplex packet according to its version */
	if (   (ETH_BUF->type == UIP_HTONS(UIP_ETHTYPE_IP))
		&& ((IPV4_BUF->vhl & 0xf0) == 0x40) ) {
//		printf("ipv4\n");	printf("\n");// TODO @@@jwg
		/* IPv4. Update ARP cache and push the packet into the IPv4 stack. 
		 * Note that uipv4_arp_ipin() substracts the Ethernet header length from 
		 * uip_len */
		uipv4_arp_ipin();
		NETSTACK_NETWORK_IPV4.input();
	}
	else if ( ETH_BUF->type == UIP_HTONS(UIP_ETHTYPE_ARP) ) {
//		printf("ARP\n");	printf("\n");// TODO @@@jwg
		/* The packet is an ARP packet. 
		 * Note that uipv4_arp_arpin() expects uip_len to include the length of the 
		 * Ethernet header */
		uipv4_arp_arpin();

		if ( uip_len > 0 ) {
			/* ARP generated an outgoing packet. Send it*/
			NETSTACK_ETHERNET.send(uip_buf, uip_len);

			/* Clear uip_len */
			uip_len = 0;
		}
	}
	else if (    (ETH_BUF->type == UIP_HTONS(UIP_ETHTYPE_IPV6) )
			  && ((IPV6_BUF->vtc & 0xf0) == 0x60) ) {
//		printf("ipv6(> %d)\n", uip_len);printf("\n"); // TODO @@@jwg

		/* IPv6. Substract the Ethernet header length from uip_buf and pass this 
		 * packet to the 6LP-GW logic */
		uip_len -= sizeof(struct uip_eth_hdr);

		NETSTACK_6LPGW.input();
	}
	else {
		/* Crap received */
		printf("eth0: crap...\n"); printf("\n"); // TODO @@@jwg
		uip_len = 0;
	}
}

/*---------------------------------------------------------------------------*/
static void
on(void)
{
  NETSTACK_ETHERNET.on();
}
/*---------------------------------------------------------------------------*/
static void
off(void)
{
  NETSTACK_ETHERNET.off();
}
/*---------------------------------------------------------------------------*/
static void
init(void)
{
	uipv4_arp_init();
	process_start(&mac_eth_process, NULL);
}
/*---------------------------------------------------------------------------*/
const struct mac_eth_driver mac_eth_driver = {
  "mac_eth_driver",
  init,
  send_packet,
  input_packet,
  on,
  off,
};
/*---------------------------------------------------------------------------*/
